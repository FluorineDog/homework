/*
 * Peg solitaire solver
 *
 * 15-122 Principles of Imperative Computation */

#use < args >
#use < conio >
#use < util >

typedef int move;

int row_start(move m) { return m & 0xF; }

int col_start(move m) { return (m >> 4) & 0xF; }

int row_end(move m) { return (m >> 8) & 0xF; }

int col_end(move m) { return (m >> 12) & 0xF; }

bool check_valid(int rc) { return 0 <= rc && rc < 8; }

void discard(board B, move m) {
  int row2 = row_start(m);
  int col2 = col_start(m);
  int row0 = row_end(m);
  int col0 = col_end(m);
  int row1 = (row0 + row2) / 2;
  int col1 = (col0 + col2) / 2;
  set_slot(B, row0, col0, 0);
  set_slot(B, row1, col1, 1);
  set_slot(B, row2, col2, 1);
}

move try_move(board B, stack S, int row0, int col0, int row_off, int col_off)
//@requires check_valid(row0);
//@requires check_valid(col0);
//@requires row_off * row_off + col_off * col_off == 1;
{
  int row1 = row0 + row_off * 1;
  int row2 = row0 + row_off * 2;
  int col1 = col0 + col_off * 1;
  int col2 = col0 + col_off * 2;
  if (!check_valid(row2) || !check_valid(col2)) {
    return false;
  }
  int s0 = get_slot(B, row0, col0);
  int s1 = get_slot(B, row1, col1);
  int s2 = get_slot(B, row2, col2);
  if (s0 == 0 && s1 == 1 && s2 == 1) {
    set_slot(B, row0, col0, 1);
    set_slot(B, row1, col1, 0);
    set_slot(B, row2, col2, 0);
    move m = 0 | row2 << 0 | col2 << 4 | row0 << 8 | col0 << 12;
    if (m != 0) {
      push(S, m);
      int result = peg_solve(B, S);
      if (result == 1) {
        return 1;
      } else {
        set_slot(B, row0, col0, 0);
        set_slot(B, row1, col1, 1);
        set_slot(B, row2, col2, 1);
      }
    }
  }
  return 0;
}

int peg_solve(board B, stack S)
//@requires is_board(B);
//@requires num_pegs(B) >= 1;
//@requires stack_empty(S);
//@ensures is_board(B);
//@ensures result >= 1;
{
  for (int row = 0; row < 8; row++) {
    for (int col = 0; col < 8; col++) {
      move = try_move(B, 1, 0);
    }
  }
}
