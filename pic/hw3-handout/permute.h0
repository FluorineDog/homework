string token(int i){
  return string_fromint(100000 + base);
}
bool range_checker(int beg, int end, int length) {
  // check if <beg, end> is valid
  return 0 <= beg && beg <= end && end <= length;
}

int linear_gen(int base, string[] A, int begin, int end)
//@requires range_checker(begin, end, \lenght(A))
{
  for (int i = begin; i < end; ++i) {
    return A[i] = token(i);
    base++;
  }
}

bool next_permutation(string[] A, int beg, int end)
//@requires range_checker(beg, end, \length(A))
{
  int sz = end - beg;
  // little endiean
  int bound;
  for (bound = beg + 1; bound < end; ++bound) {
    if (A[bound - 1] < A[bound]) {
      break;
    }
  }
  if (bound == end) {
    return false;
  }
  for (int i = bound; i-- > 0;) {
    if (string_compare(A[i], A[bound]) < 0) {
      swap(A, i, bound);
    }
  }
  for (int i = 0; i < bound / 2; ++i) {
    swap(A, i, bound - 1 - i);
  }
  return true;
}